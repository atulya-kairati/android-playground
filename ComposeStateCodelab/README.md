# State in Compose

- State is anything that can change over time and needs to be remembered and presented to the user through UI.
- State can can range from a variable to a DB.
- Any action that causes the modification of state is called an "event".
- Events are inputs generated from outside or inside an application, such as:
	- The user interacting with the UI by, for example, pressing a button.
	- Other factors, such as sensors sending a new value, or network responses.

- While the state of the app offers a description of what to display in the UI, events are the mechanism through which the state changes, resulting in changes to the UI.

![UI update loop](./ui_update_loop.png "UI update loop/")

- **Event** - An event is generated by the user or another part of the program.
- **Update State** - An event handler changes the state that is used by the UI.
- **Display State** - The UI is updated to display the new state.


- Compose apps build a description of the UI called *Composition* by calling compose functions.
- If the state changes, then then the parts depending on that state are *Re-Composed*.

- **The Composition**: a description of the UI built by Jetpack Compose when it executes composables.

- **Initial composition**: creation of a Composition by running composables the first time.

- **Recomposition**: re-running composables to update the Composition when data changes.

- Compose has a special state tracking system in place that schedules recompositions for any composables that read a particular state. This lets Compose be granular and just recompose those composable functions that need to change, not the whole UI. This is done by tracking not only "writes" (that is, state changes), but also "reads" to the state.

- Compose tracks variable which are of type `State` or `MutableState` (But it must be used with remember and its variants).

- Compose keeps track of each composable that reads State value properties and triggers a recomposition when its value changes. 
***

## Remembering state with `remember`:

- **Remember**: `remember` stores objects in the Composition, and forgets the object if the source location where `remember` is called is not invoked again during a recomposition.

- While `remember` helps you retain state across recompositions, it's not retained across configuration changes. For this, you must use rememberSaveable instead of remember.

- `rememberSaveable` automatically saves any value that can be saved in a `Bundle`. For saving custom objects refer ![Restoring state in Compose](https://developer.android.com/jetpack/compose/state#restore-ui-state).

- `rememberSaveable` will not only survive recompostion and activity recreation but also process death since it uses savedStateHandle internally.
***

## State Hoisting

- A composable that uses remember to store an object contains internal state, making the composable **stateful**.
- **Stateful** composables are useful when the caller doesn't need to control the state. But they are less reusable and are harder to test.

- **Stateless** composable on the other hand, don't have internal state.

- Easy way to convert Stateful composable to Stateless is by using **State Hoisting**.
- State hoisting in Compose is a pattern of moving state to a composable's caller to make a composable stateless.
- The general pattern for state hoisting in Jetpack Compose is to replace the state variable with two parameters:
```kotlin
value: T - the current value to display
onValueChange: (T) -> Unit - an event that requests the value to change, where T is the proposed new value
```
where `value` represents any state that could be modified.

- Here state goes down to the composable and the changes to the state (events) come up. This is Unidirectional Flow architecture.

- State that is hoisted this way has some important properties:
	- **Single source of truth**: By moving state instead of duplicating it, we're ensuring there's only one source of truth. This helps avoid bugs.
	- **Shareable**: Hoisted state can be shared with multiple composables.
	- **Interceptable**: Callers to the stateless composables can decide to ignore or modify events before changing the state.
	- **Decoupled**: The state for a stateless composable function can be stored anywhere. For example, in a ViewModel.


- **Key Point**: When hoisting state, there are three rules to help you figure out where state should go:
	- State should be hoisted to at least the lowest common parent of all composables that use the state (read).
	- State should be hoisted to at least the highest level it may be changed (write).
	- If two states change in response to the same events they should be hoisted to the same level.
- You can hoist the state higher than these rules require, but if you don't hoist the state high enough, it might be difficult or impossible to follow unidirectional data flow.
***

## Observable MutableList

- To use list as state use MutableStateList.

```kotlin
val list = remember {
    getWellnessTasksList(30).toMutableStateList()
}
```

or 

```kotlin
val list = remember {
	mutableStateListOf<WellnessTask>().apply { addAll(getWellnessTasks(30)) }
}
```

**Warning**: Make sure when using such list with `items(){}` method (like in LazyColumn)
-  The items method receives a key parameter. By default, each item's state is keyed against the position of the item in the list.
- In a mutable list, this causes issues when the data set changes, since items that change position effectively lose any remembered state.
- Use `key` argument to get over this issue.

**Warning**: 
- `rememberSaveable` won't work with mutable state list.
- Don't use remember method for large data, use view model instead.
